//

const NOMINATIM_URL = (locStringEncoded) => `https://nominatim.openstreetmap.org/search?q=${locStringEncoded}&polygon_geojson=1&limit=5&polygon_threshold=0.005&format=json`;

let mapSettings = {
    Name: "",
    Polygon: null,
    Area: 0,
    NumRounds: 0,
    TimeLimit: 0,
    GraceDistance: 10,
    MinDensity: 0,
    MaxDensity: 100,
    Connectedness: 0,
    Copyright: 0,
    Source: 0,
    ShowLabels: true
};
let locString = "";
let previewMap;
let previewPolyGroup;

document.addEventListener('DOMContentLoaded', (event) => {
    previewMap = L.map("bounds-map", {center: [0, 0], zoom: 1});
    L.tileLayer("{{ .TileServerURL }}", {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors, <a href="https://wikitech.wikimedia.org/wiki/Wikitech:Cloud_Services_Terms_of_use">Wikimedia Cloud Services</a>'
    }).addTo(previewMap);
    previewPolyGroup = L.layerGroup().addTo(previewMap);
});

// collates createmap form data into a JSON object, 
// then sends a newmap request to the server
function handleFormSubmit() {
    mapSettings.Name          = strById("Name");
    mapSettings.NumRounds     = intById("NumRounds");
    mapSettings.GraceDistance = intById("GraceDistance");
    mapSettings.MinDensity    = intById("MinDensity");
    mapSettings.MaxDensity    = intById("MaxDensity");
    mapSettings.Connectedness = intById("Connectedness");
    mapSettings.Copyright     = intById("Copyright");
    mapSettings.Source        = intById("Source");
    
    showLabelsInput = document.getElementById("ShowLabels");
    if (showLabelsInput) {
        mapSettings.ShowLabels = showLabelsInput.checked;
    }

    // read total TimeLimit
    mapSettings.TimeLimit = 0;
    mapSettings.TimeLimit += 60 * intById("TimeLimit_minutes");
    mapSettings.TimeLimit += intById("TimeLimit_seconds");

    // sanity check density fields
    // TODO: nicer error messages than alerts
    // TODO: check that population density in Polygon overlaps with the
    //       specified range (otherwise we'll never be able to find good
    //       panos.)
    if (mapSettings.MinDensity > mapSettings.MaxDensity) {
        alert("Max density must be greater than min density.");
        return;
    }
    // TODO: evaluate challenge generation (to make sure mapSettings aren't so
    //       specific that it takes a huge number of API requests to find good
    //       panos)
    // send to server /newmap
    fetch("/newmap", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify(mapSettings),
    }).then(console.log("mapSettings sent to server"));
}

function intById(id, fallback=0) {
    input = document.getElementById(id);
    if (input) {
        if (!input.value) {
            return fallback;
        }
        return parseInt(input.value, 10);
    } else {
        console.log("Couldn't find input '" + id + "', using fallback.")
        return fallback;
    }
}

function strById(id, fallback="") {
    input = document.getElementById(id);
    if (input) {
        return input.value;
    } else {
        console.log("Couldn't find input '" + id + "', using fallback.")
        return fallback;
    }
}

function locStringUpdated() {
    let old = locString;
    let locStringInput = document.getElementById("locString");
    if (locStringInput) {
        locString = document.getElementById("locString").value;
    }
	if (old !== locString) {
        updatePolygonFromLocString();
	}
}

function showPolygonOnMap() {
    previewPolyGroup.clearLayers();
	let map_poly = L.geoJSON(mapSettings.Polygon).addTo(previewPolyGroup);
	previewMap.fitBounds(map_poly.getBounds());
}

function updatePolygonFromLocString() {
	if (locString === "" || !locString) {
		mapSettings.Polygon = null;
		return;
    }
    
    fetch(NOMINATIM_URL(encodeURI(locString.replace(" ", "+"))))
        .then(response => response.json())
        .then(data => {
            mapSettings.Polygon = geojsonFromNominatim(data);
            mapSettings.Area = turf.area(mapSettings.Polygon);
            showPolygonOnMap();
        });
}

// given Nominatim results, takes the most significant one with a polygon or
// multipolygon and returns it as a turf.multiPolygon
function geojsonFromNominatim(data) {
    console.log("getting geojson...");
    for (let i = 0; i < data.length; i++) {
        let type = data[i].geojson.type.toLowerCase();
        if (type === "multipolygon") {
            return turf.multiPolygon(data[i].geojson.coordinates);
        } else if (type === "polygon") {
            return turf.multiPolygon([data[i].geojson.coordinates]);
        }
    }
    console.log("No matching polygon!");
    return null;
}