// TODO: FIXME: clean up/use async properly
// TODO: This script currently assumes that mapSettings is good and valid.
//       However, there's no validation in place to make sure that is the
//       case.  We should either handle missing/bad information here, or
//       implement a "trial run" fetchPanos at the end of the map creation
//       process.

// search radius in meters - using 500 (formerly 50,000) causes more NO_RESULTS
// responses, but the API also takes much less time to fulfill the requests.
// It also means we can use StreetViewPreference.BEST without so many duplicate
// responses.
const PANO_SEARCH_RADIUS = 500;
// NEAREST or BEST.  BEST seems to give more actual streetview results (rather
// than third party photospheres) so I'm going with that.
const SV_PREF = google.maps.StreetViewPreference.BEST;
// discard polar panos, they're usually garbage
const LAT_LIMIT = 85;
const mapURL = "/map?id="
const popTIFLoc = "/static/nasa_pop_data.tif"

let statusReadout;

let streetViewService = new google.maps.StreetViewService();

let mapSettings = undefined;
let popTIF = undefined;

let mapID;
let foundCoords = [];

document.addEventListener('DOMContentLoaded', async (event) => {
    statusReadout = document.getElementById("status");
    statusReadout.textContent = "Looking up population density data...";
    popTIF = await loadGeoTIF(popTIFLoc);
    statusReadout.textContent = "Getting Map settings...";
    mapSettings = await fetchMapSettings(mapURL);
    statusReadout.textContent = "Fetching panoramas...";
    console.log(mapSettings);
    fetchPanos(streetViewService, mapSettings);
});

function updateUI(numFound, numRounds) {
    bar = document.getElementById("loading-progress")
    bar.setAttribute("style", "width: " + ((100 * numFound) / numRounds) + "%;");
	bar.textContent = numFound.toString() + "/" + numRounds.toString();
	if (numFound == numRounds) {
		document.getElementById("status").textContent = "Done!";
		document.getElementById("submit-button").disabled = false;
	}
}

// TODO: remove debug
function printCoords() {
    foundCoords.forEach((coord) => {console.log(coord.lat().toString() + ", " + coord.lng().toString())});
}

function handleNewChallenge() {
	let convertedCoords = foundCoords.map((coord, i) => ({RoundNum: i, Location: {Lat: coord.lat(), Lng: coord.lng()}}));
	let challenge = JSON.stringify({
		MapID: mapID,
		Places: convertedCoords
	});

	console.log(challenge);
	fetch("/newchallenge", {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
		},
		body: challenge,
	}).then(console.log("challenge sent to server"));
}

// == MAP SETTINGS ========
async function fetchMapSettings(url) {
    let params = new URLSearchParams(window.location.search)
    if (!params.has("mapid")) {
        alert("URL has no map ID!");
        return;
    }
    mapID = params.get("mapid");
    let response = await fetch(url+mapID);
    return response.json();
}

// == POPULATION DENSITY ========
async function loadGeoTIF(loc) {
	const response = await fetch("/static/nasa_pop_data.tif");
	const arrayBuffer = await response.arrayBuffer();
	return await GeoTIFF.fromArrayBuffer(arrayBuffer);
}
// get normalized (0.0 - 1.0) population density at lat, lng
async function getLocationPopulation(lat, lng) {
    const delta = 0.1;
    // TODO: consider passing popTIF as arg
	let value = await popTIF.readRasters({
		bbox: [lng, lat, lng + 10 * delta, lat + 10 * delta],
		resX: delta,
		resY: delta,
	});
	let actualValue = value[0][0];
	// 255 means ocean
	if (actualValue == 255) {
		actualValue = 0;
	}
	return actualValue / 255;
}

// == GET PANOS ========
async function fetchPanos(svService, settings) {
    const promises = [];
    for (let i = 0; i < settings.NumRounds; i++) {
        promises.push(fetchPano(svService, settings));
    }
    return Promise.all(promises);
}

async function fetchPano(svService, settings) {
    let randomLatLng = await getRandomConstrainedLatLng(settings.Polygon, settings.MinDensity, settings.MaxDensity);
    
    async function handlePanoResponse(result, status) {
        if (status == google.maps.StreetViewStatus.OK && resultPanoIsGood(result, settings)) {
            foundCoords.push(result.location.latLng);
			updateUI(foundCoords.length, settings.NumRounds);
		} else {
			console.log("Failed to get location; api request: " + status.toString() + "\n");
			fetchPano(svService, settings);
		}
    }

    let source = settings.Source == 1 ? google.maps.StreetViewSource.OUTDOOR : google.maps.StreetViewSource.DEFAULT;
	streetViewService.getPanorama({
		location: randomLatLng,
		preference: SV_PREF,
		radius: PANO_SEARCH_RADIUS,
		source: source,
	}, handlePanoResponse);
}

// returns whether result (pano) meets the requirements of mapInfo
function resultPanoIsGood(result, settings) {
	if (result.location.latLng.lat() > LAT_LIMIT || result.location.latLng.lat() < -1 * LAT_LIMIT) {return false;}

	if (settings.Copyright == 1 && !result.copyright.includes("Google")) {
		return false;
	}
	if (settings.Copyright == 2 && result.copyright.includes("Google")) {
		return false;
	}

	if (settings.Connectedness == 1 && result.links.length == 0) {
		return false;
	}
	if (settings.Connectedness == 2 && result.links.length > 0) {
		return false;
	}

	let locationTurfPoint = turf.point([result.location.latLng.lng(), result.location.latLng.lat()]);
	if (settings.Polygon != null && !turf.booleanPointInPolygon(locationTurfPoint, settings.Polygon)) {
		return false;
	}

	// TODO: duplicate checking that doesn't rely on globals
	//       and doesn't have a race condition
	for (let i = 0; i < foundCoords.length; i++) {
		if (foundCoords[i].equals(result.location.latLng)) {
			console.log("duplicate!");
			return false;
		}
	}

	return true;
}

// get a random google.maps.LatLng within the specified polygon and with
// a population density in the specified range
async function getRandomConstrainedLatLng(polygon, minDensity, maxDensity) {
	// TODO: function assignment as control flow is heinous
	let getRandomLngLatInBounds;
	let pointInPolygon;
	if (polygon == null) {
		getRandomLngLatInBounds = getRandomLngLat;
		pointInPolygon = (_) => true;
	} else {
		let bounds = turf.bbox(polygon);
		getRandomLngLatInBounds = function() {
			randomLng = (Math.random() * (bounds[2] - bounds[0]) + bounds[0]);
			randomLat = (Math.random() * (bounds[3] - bounds[1]) + bounds[1]);
			return [randomLng, randomLat];
		}
		pointInPolygon = function(lnglat) {
			return turf.booleanPointInPolygon(turf.point(lnglat), polygon);
		}
	}

	async function popDensityInLimits(lnglat) {
		let density = (await getLocationPopulation(lnglat[1], lnglat[0])) * 100;
		return density <= maxDensity && density >= minDensity;
	}
	
	let lnglat;
	do {
		lnglat = getRandomLngLatInBounds();
	} while (!pointInPolygon(lnglat) || !(await popDensityInLimits(lnglat)));
	return new google.maps.LatLng(lnglat[1], lnglat[0]);
}

// get a random google.maps.LatLng, anywhere
function getRandomLngLat() {
	let randomLng = (Math.random() * 360 - 180);
	let randomLat = (Math.random() * 180 - 90);
	return [randomLng, randomLat];
}