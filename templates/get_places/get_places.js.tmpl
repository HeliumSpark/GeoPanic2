// TODO: This file is getting out of hand.
//
// StreetViewService return service:
// {
//   "location": {
//     "latLng": LatLng,
//     "description": string,
//     "pano": string
//   },
//   "copyright": string,
//   "links": [{
//       "heading": number,
//       "description": string,
//       "pano": string,
//       "roadColor": string,
//       "roadOpacity": number
//     }],
//   "tiles": {
//     "worldSize": Size,
//     "tileSize": Size,
//     "centerHeading": number
//   }
// }

let debug = false;

const PANO_SEARCH_RADIUS = 50000;
const LAT_LIMIT = 85; // polar panos are discarded, they're usually garbage
// string formatting in javascript...
const NOMINATIM_URL = (locStringEncoded) => `https://nominatim.openstreetmap.org/search?q=${locStringEncoded}&polygon_geojson=1&limit=5&format=json`;

const FETCH_PANO_POOL = 10; // Maximum simultaneous connections to fetch panos

let streetViewService = new google.maps.StreetViewService();

// loadGeoTiff gets awaited at the start, so geoImage is always present.
let tiff = undefined;
// let geoImage = undefined;
// let geoData = undefined;
async function loadGeoTiff() {
	const response = await fetch("/static/nasa_pop_data.tif");
	const arrayBuffer = await response.arrayBuffer();
	tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
	// geoImage = await tiff.getImage();
	// [geoData] = await geoImage.readRasters();
}
async function getLocationPopulation(lat, lng) {
	const delta = 0.1;
	let value = await tiff.readRasters({
		bbox: [lng, lat, lng + 10 * delta, lat + 10 * delta],
		resX: delta,
		resY: delta,
	});
	let actualValue = value[0][0];
	// 255 means ocean
	if (actualValue == 255) {
		actualValue = 0;
	}
	return actualValue / 255;
}

// TODO: decouple form text from option/state (use enum?)
let pageMapInfo = {
	"numRounds": 5,
	"locStrings": [],
	"locPolygon": null,
	"panoReqs": {
		"panoConnectedness": "always",
		"populationMin": 0.15,
		"populationMax": 1,
		"outdoors": "outdoors only",
		"copyright": "any",
	},
	"panoCoords": [],
	"shouldUpdate": false,
	"updateId": null,
}

let numPanoFetchesInProgress = 0;

let previewMap = null;
let markerGroup = null; // DEBUGGING: map layer group for place markers
let polygonGroup = null; // map layer group for polygon regions

let fetchTimer = null; // timer id for fetching locations

// given a turf.polygon or turf.multiPolygon,
// display it on the map, and fit the map to its bounds
function showPolygonOnMap(map, polygon) {
	let map_poly = L.geoJSON(polygon).addTo(polygonGroup);
	if (debug) {
		console.log(map_poly.getBounds());
	}
	map.fitBounds(map_poly.getBounds());
}

/**
 * Given an array of locStrings, will return a polygon from nominatim
 * @todo add support for multiple locStrings
 * @param locStrings the array of locString
 */
function fetchPolygonFromLocString(locStrings) {
	const locString = locStrings[0];

	return new Promise((resolve, reject) => {
		if (locString === "" || !locString) {
			return resolve(null);
		}

		// Send request to nominatim
		const Http = new XMLHttpRequest();
		const url = NOMINATIM_URL(encodeURI(locString.replace(" ", "+")));
		Http.open("GET", url);
		Http.send();

		Http.onreadystatechange = (event) => {
			if (Http.readyState == 4) {
				let placesPolygon;
				let response = JSON.parse(Http.responseText);
	
				// Search for the polygon
				for (let i = 0; i < response.length; i++) {
					let type = response[i]["geojson"]["type"].toLowerCase();
					if (type === "multipolygon") {
						// Print to console when debugging
						if (debug) {
							console.log(response[i]);
						}

						placesPolygon = turf.multiPolygon(response[i]["geojson"]["coordinates"]);
						break;
					} else if (type === "polygon") {
						// Print to console when debugging
						if (debug) {
							console.log(response[i]);
						}

						placesPolygon = turf.multiPolygon([response[i]["geojson"]["coordinates"]]);
						break;
					}
				}
	
				// Reject, if the response is not a polygon
				if (!placesPolygon) {
					return reject(null);
				}
	
				return resolve(placesPolygon);
			}
		}
	});
}

// ===== API/Panorama Fetching =====

// mapInfo object format (type and default in parens):
/*
{
	"numRounds": (int > 0, default to 5)
	"locStrings": (array of strings, default to [])
	"locPolygon": (turf.multiPolygon, default to null TODO: convert polygon to multiPolygon)
	"panoReqs": {
		"panoConnectedness": (string, one of ["always", "never", "any"], default to "any")
		"populationMin": (between 0 and 1, default 0),
		"populationMax": (between 0 and 1, default 1),
	}
	// TODO: consider storing addition pano information, such as connectedness
	"panoCoords": (array of google.maps.LatLng, default to [])
}
*/
async function fetchPanos(id) {

	updateFetchingBar(0);

	const panos = [];
	const executing = [];

	const enqueue = function() {
		// If a new config is available, stop
		if (id !== pageMapInfo["updateId"]) {
			return Promise.reject();
		}

		if (panos.length >= pageMapInfo["numRounds"]) {
			return Promise.resolve();
		}

		// Fetch Pano
		const p = fetchPano(pageMapInfo).then(pano => {

			// Check for duplicates
			for (let i = 0; i < panos.length; i++) {
				if (panos[i].equals(pano)) {
					console.log("duplicate!");
					return null;
				}
			}

			if (debug && panos.length < pageMapInfo["numRounds"]) {
				L.marker([pano.lat(), pano.lng()]).addTo(markerGroup); // DEBUGGING: show selected places on map
			}

			panos.push(pano);

			updateFetchingBar(Math.min(panos.length / pageMapInfo["numRounds"], 1));

		}).catch(() => null);

		const exec = p.then(() => executing.splice(executing.indexOf(exec), 1));
		executing.push(exec);

		let r = Promise.resolve();
		if (executing.length >= FETCH_PANO_POOL) {
			r = Promise.race(executing);
		}

		return r.then(() => enqueue());
	}

	await enqueue();

	pageMapInfo["panoCoords"] = panos.slice(0, pageMapInfo["numRounds"]);

	updateSecretForm(pageMapInfo["panoCoords"], pageMapInfo["numRounds"]);
}

/**
 * Call this whenever the mapInfo changes and new panos should be generated
 */
function updatedMapInfo() {
	disableSubmitButton();

	updateFetchingBar(0);
	
	pageMapInfo["shouldUpdate"] = true;

	if (!fetchTimer) {
		fetchTimer = setInterval(() => {
			if (pageMapInfo["shouldUpdate"]) {
				pageMapInfo["shouldUpdate"] = false;

				// Mark this update cycle
				const id = Date.now();
				pageMapInfo["updateId"] = id;

				if (debug) {
					markerGroup.clearLayers();
				}
				
				pageMapInfo["panoCoords"] = [];

				fetchPanos(id).then(() => {
					console.log("Finished fetching locations; id: " + id);
				}).catch("Aborted fetching locations; id: " + id);
			}
		}, 100);
	}
}

/**
 * Fetch a random location return it. If the location is not valid, reject.
 * Repetition of fetches has to be done by the caller
 * @param mapInfo current map info
 */
async function fetchPano(mapInfo) {
	return new Promise(async (resolve, reject) => {
		let randomLatLng = getRandomLatLngInPolygon(mapInfo["locPolygon"]);
	
		function handlePanoResponse(result, status) {
			if (status == google.maps.StreetViewStatus.OK && resultPanoIsGood(result, mapInfo)) {
				return resolve(result.location.latLng);
			} else {
				if (debug) {
					console.log("Failed to get location; api request: " + status.toString() + "\n");
				}
				return reject();
			}
		}
	
		let source = mapInfo["outdoors"] === "outdoors only" ? google.maps.StreetViewSource.OUTDOOR : google.maps.StreetViewSource.DEFAULT;
		let population = await getLocationPopulation(randomLatLng.lat(), randomLatLng.lng());
		let min = mapInfo["panoReqs"]["populationMin"];
		let max = mapInfo["panoReqs"]["populationMax"];
		if (population >= min && population <= max) {
			streetViewService.getPanorama({
				location: randomLatLng,
				preference: google.maps.StreetViewPreference.NEAREST,
				radius: PANO_SEARCH_RADIUS,
				source: source,
			}, handlePanoResponse);
		} else {
			reject();
		}
	});
}

// returns whether result (pano) meets the requirements of mapInfo
function resultPanoIsGood(result, mapInfo) {
	if (result.location.latLng.lat() > LAT_LIMIT || result.location.latLng.lat() < -1 * LAT_LIMIT) {return false;}

	if (mapInfo["panoReqs"]["copyright"] === "Google only" && !result.copyright.includes("Google")) {
		return false;
	}
	if (mapInfo["panoReqs"]["onlyGoogle"] === "third party only" && result.copyright.includes("Google")) {
		return false;
	}

	if (mapInfo["panoReqs"]["panoConnectedness"] === "always" && result.links.length == 0) {
		return false;
	}
	if (mapInfo["panoReqs"]["panoConnectedness"] === "never" && result.links.length > 0) {
		return false;
	}

	let locationTurfPoint = turf.point([result.location.latLng.lng(), result.location.latLng.lat()]);
	if (mapInfo["locPolygon"] != null && !turf.booleanPointInPolygon(locationTurfPoint, mapInfo["locPolygon"])) {
		return false;
	}

	return true;
}

// =====

function disableSubmitButton() {
	let button = document.getElementById("submit-button");
	button.setAttribute("disabled", "disabled");
	button = document.getElementById("refresh-panos-button");
	button.setAttribute("disabled", "disabled");
}

// update loading/fetching progress bar with number of panoCoords found
function updateFetchingBar(value) {
	document.getElementById("loading-progress").setAttribute("style", "width: " + (100 * value) + "%;");
}

function showErrorMessage(message) {
	const errorDialog = document.getElementById("error-dialog");
	errorDialog.removeAttribute("hidden");
}

function hideErrorMessage() {
	const errorDialog = document.getElementById("error-dialog");
	errorDialog.setAttribute("hidden", "hidden");
}

// put panoCoords into the hidden form input
// TODO: this is a hack
// re-enables the submit button
function updateSecretForm(panoCoords, numRounds) {
	if (panoCoords.length >= numRounds) {
		if (panoCoords.length > numRounds) {
			console.warn("Too many panoCoords?! mapInfo:");
		}
		let input = document.getElementById("hidden-input");
		input.setAttribute("value", JSON.stringify(panoCoords));
		let button = document.getElementById("submit-button");
		button.removeAttribute("disabled");
		button = document.getElementById("refresh-panos-button");
		button.removeAttribute("disabled");
	}
}

// get a random google.maps.LatLng, anywhere
function getRandomLatLng() {
	let randomLng = (Math.random() * 360 - 180);
	let randomLat = (Math.random() * 180 - 90);
	return new google.maps.LatLng(randomLat, randomLng);
}

// get a random google.maps.LatLng within the specified turf.polygon or turf.multiPolygon
function getRandomLatLngInPolygon(polygon) {
	if (!polygon) {
		// fall back to global
		return getRandomLatLng();
	}
	bounds = turf.bbox(polygon);
	let randomLng;
	let randomLat;
	let lnglat;
	// TODO: more efficient algorithm? - suffices for the small number of points needed
	do { 
		randomLng = (Math.random() * (bounds[2] - bounds[0]) + bounds[0]);
		randomLat = (Math.random() * (bounds[3] - bounds[1]) + bounds[1]);
		lnglat = turf.point([randomLng, randomLat]);
	} while (!turf.booleanPointInPolygon(lnglat, polygon))
	//L.marker([randomLat, randomLng]).addTo(markerGroup); // DEBUGGING: show _all_ random points on map
	return new google.maps.LatLng(randomLat, randomLng);
}

// ===== Form Change Handlers =====


function numberOfRoundsUpdated() {
	let newNumRounds = document.getElementById("rounds").value;
	if (!newNumRounds) {
		return;
	}
	if (newNumRounds < pageMapInfo["numRounds"]) {
		// note: can't decrease length of panoCoords beyond 0, so any excess requests are handled in fetchPano()
		pageMapInfo["panoCoords"] = pageMapInfo["panoCoords"].slice(0, newNumRounds);
	}
	pageMapInfo["numRounds"] = newNumRounds;
	
	updatedMapInfo();
}

function forceUpdatePanos() {
	updatedMapInfo();
}

function connectedOnlyUpdated() {
	// TODO: improve user-friendliness of these values
	let newConnectedOnly = document.getElementById("connectedOnly").value;
	if (pageMapInfo["panoReqs"]["panoConnectedness"] !== newConnectedOnly) {
		pageMapInfo["panoReqs"]["panoConnectedness"] = newConnectedOnly;
		
		updatedMapInfo();
	}
}

function outdoorsUpdated() {
	let newOutdoors = document.getElementById("outdoors").value;
	if (pageMapInfo["panoReqs"]["outdoors"] !== newOutdoors) {
		pageMapInfo["panoReqs"]["outdoors"] = newOutdoors;
		
		updatedMapInfo();
	}
}

function onlyGoogleUpdated() {
	let newOnlyGoogle = document.getElementById("onlyGoogle").value;
	if (pageMapInfo["panoReqs"]["copyright"] !== newOnlyGoogle) {
		pageMapInfo["panoReqs"]["copyright"] = newOnlyGoogle;
		
		updatedMapInfo();
	}
}

// TODO: support multiple loc strings
async function locStringUpdated() {
	let old = pageMapInfo["locStrings"][0];
	let newLocString = document.getElementById("locString").value;
	if (old !== newLocString) {
		disableSubmitButton();
		pageMapInfo["locStrings"][0] = newLocString;

		const polygon = await fetchPolygonFromLocString([newLocString]).then(pol => {
			hideErrorMessage();
			return pol;
		}).catch(() => {
			if (debug) {
				console.log("Error while fetching polygon");
			}
			
			showErrorMessage();
			return null;
		});

		// In case the locString was updated during request, ignore result
		if (pageMapInfo["locStrings"][0] !== newLocString) {
			if (debug) {
				console.log("locString changed while fetching polygon");
			}

			return;
		}


		// Make sure to update
		pageMapInfo["shouldUpdate"] = true;

		// Set polygon in pageMapInfo
		pageMapInfo["locPolygon"] = polygon;

		// Make sure to update
		updatedMapInfo();

		// Reset view, if no polygon was returned
		if (!polygon) {
			if (debug) {
				console.log("Resetting polygon to global");
			}

			previewMap.setView([0, 0], 1);
			polygonGroup.clearLayers();
			return;
		}

		// Show polygon on map
		showPolygonOnMap(previewMap, polygon);
	}
}

function popDensityUpdated() {
	let newMin = document.getElementById("minDensity").value / 100;
	let newMax = document.getElementById("maxDensity").value / 100;
	let oldMin = pageMapInfo["panoReqs"]["populationMin"];
	let oldMax = pageMapInfo["panoReqs"]["populationMax"];
	if (newMin !== oldMin || newMax !== oldMax) {
		pageMapInfo["panoReqs"]["populationMin"] = newMin;
		pageMapInfo["panoReqs"]["populationMax"] = newMax;
		
		updatedMapInfo();
	}
}

// settings may have been cached by the browser (wouldn't trigger the onchange),
// so check them once the DOM has loaded
window.addEventListener("DOMContentLoaded", (_) => {
	// TODO: stick map stuff in a function
	let load = async function() {
		await loadGeoTiff();
		previewMap = L.map("bounds-map", {center: [0, 0], zoom: 1});
		L.tileLayer("{{ .Config.TileServerURL }}", {
			attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors, <a href="https://wikitech.wikimedia.org/wiki/Wikitech:Cloud_Services_Terms_of_use">Wikimedia Cloud Services</a>'
		}).addTo(previewMap);
		markerGroup = L.layerGroup().addTo(previewMap);
		polygonGroup = L.layerGroup().addTo(previewMap);
		numberOfRoundsUpdated();
		connectedOnlyUpdated();
		locStringUpdated();
		popDensityUpdated();
	};
	load();
});
